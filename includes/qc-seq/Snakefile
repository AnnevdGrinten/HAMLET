from os import path
from rattle import Run, ReadGroup, Sample


RUN = Run(config)

RUN.set_default_setting("rg_stats_script", srcdir(path.join("scripts", "gather_rg_stats.py")))
RUN.set_default_setting("sample_stats_script", srcdir(path.join("scripts", "gather_sample_stats.py")))

containers = {
    "crimson": "docker://quay.io/biocontainers/crimson:0.3.0--py27_1",
    "cutadapt": "docker://quay.io/biocontainers/cutadapt:1.14--py36_0",
    "debian": "docker://debian:buster-slim",
    "fastqc": "docker://quay.io/biocontainers/fastqc:0.11.8--1"
}

rule all_qc:
    input:
        fqs=[RUN.output("{sample}/{sample}-{pair}.fq.gz", fmt=True,
                        sample=unit.sample, pair=pair)
             for unit in RUN.unit_names for pair in ("R1", "R2")],
        stats=expand(RUN.output("{sample}/qc-seq/{sample}.seq_stats.json"),
                     sample=RUN.samples),


rule fastqc_raw:
    """Runs FastQC for each pair of each read group of each sample given in the config file."""
    input:
        fq=RUN.config_input_func(ReadGroup, "{pair}"),
    output:
        dir=directory(RUN.output("{sample}/qc-seq/{read_group}/fastqc-{{pair}}-raw", fmt=True)),
    threads: 4
    conda: srcdir("envs/fastqc.yml")
    singularity: containers["fastqc"]
    shell:
        "mkdir -p {output.dir}"
        " && fastqc -o {output.dir} --extract --nogroup -f fastq --threads {threads} {input.fq}"


rule cutadapt:
    """Clip fastq files"""
    input:
        fq1=RUN.config_input_func(ReadGroup, "R1"),
        fq2=RUN.config_input_func(ReadGroup, "R2"),
    output:
        fq1=temp(RUN.output("{sample}/qc-seq/{read_group}/{sample}-{read_group}-R1.fq.gz")),
        fq2=temp(RUN.output("{sample}/qc-seq/{read_group}/{sample}-{read_group}-R2.fq.gz")),
    singularity: containers["cutadapt"]
    conda: "envs/cutadapt.yml"
    shell: "cutadapt -a AGATCGGAAGAG -A AGATCGGAAGAG "
           "--minimum-length=20 --quality-cutoff=20,20 "
           "--output={output.fq1} --paired-output={output.fq2} "
           "{input.fq1} {input.fq2}"


rule fastqc_processed:
    """Runs FastQC for each pair of QC-ed inputs."""
    input:
        fq=RUN.output("{sample}/qc-seq/{read_group}/{sample}-{read_group}-{pair}.fq.gz"),
    output:
        dir=directory(RUN.output("{sample}/qc-seq/{read_group}/fastqc-{pair}-processed")),
    threads: 4
    conda: srcdir("envs/fastqc.yml")
    singularity: containers["fastqc"]
    shell:
        "mkdir -p {output.dir}"
        " && fastqc -o {output.dir} --extract --nogroup -f fastq --threads {threads} {input.fq}"


rule rg_stats:
    """Gathers read statistics on the read group level."""
    input:
        raw1=RUN.output("{sample}/qc-seq/{read_group}/fastqc-R1-raw"),
        raw2=RUN.output("{sample}/qc-seq/{read_group}/fastqc-R2-raw"),
        proc1=RUN.output("{sample}/qc-seq/{read_group}/fastqc-R1-processed"),
        proc2=RUN.output("{sample}/qc-seq/{read_group}/fastqc-R2-processed"),
        rg_stats_script=RUN.settings["rg_stats_script"],
    output:
        stats=temp(RUN.output("{sample}/qc-seq/{read_group}/stats.json")),
    conda: srcdir("envs/rg_stats.yml")
    singularity: containers["crimson"]
    shell:
        "python {input.rg_stats_script} --name {wildcards.read_group}"
        " {input.raw1} {input.raw2} {input.proc1} {input.proc2}"
        " > {output.stats}"


rule sample_stats:
    """Gathers read statistics on the sample level."""
    input:
        rg_stats=lambda wildcards: [RUN.output("{sample}/qc-seq/{read_group}/stats.json",
                                               fmt=True, sample=wildcards.sample, read_group=rgn)
                                    for rgn in RUN.samples[wildcards.sample].read_groups],
        sample_stats_script=RUN.settings["sample_stats_script"],
    output:
        stats=RUN.output("{sample}/qc-seq/{sample}.seq_stats.json")
    conda: srcdir("envs/sample_stats.yml")
    singularity: containers["crimson"]
    shell:
        "python {input.sample_stats_script} --name {wildcards.sample}"
        " {input.rg_stats} > {output.stats}"


rule merge_fastqs:
    """Merges all FASTQ files for a given sample from its read groups."""
    input:
        fqs=lambda wildcards: [RUN.output("{sample}/qc-seq/{read_group}/{sample}-{read_group}-{pair}.fq.gz",
                                          fmt=True, sample=wildcards.sample, read_group=rgn, pair=wildcards.pair)
                               for rgn in RUN.samples[wildcards.sample].read_groups]
    output:
        fq=RUN.output("{sample}/{sample}-{pair}.fq.gz"),
    singularity: containers["debian"]
    shell:
        "zcat {input.fqs} | gzip -c > {output.fq}"


rule merge_fastqs_raw:
    """Merges all raw FASTQ files for a given sample from its read groups."""
    input:
        fqs=lambda wildcards: [rg._raw[wildcards.pair]
                               for rg in RUN.samples[wildcards.sample].read_groups.values()]
    output:
        fq=temp(RUN.output("{sample}/{sample}-{pair}.raw.fq.gz")),
    singularity: containers["debian"]
    shell:
        "zcat {input.fqs} | gzip -c > {output.fq}"
