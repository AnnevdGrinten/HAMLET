from rattle import Run

RUN = Run(config)

# TODO: ensure gtf exists
RUN.set_default_setting("base_count_script", srcdir(path.join("scripts", "hist2count.py")))
RUN.set_default_setting("aggr_base_count_script", srcdir(path.join("scripts", "aggr_base_count.R")))
RUN.set_default_setting("calc_ratio_script", srcdir(path.join("scripts", "calc_ratio.py")))

RUN.set_default_setting("relative_gene_name", "HMBS")

if not RUN.settings.get("exon_names", []):
    raise ValueError("No exon names for exon ratio calculation defined")


rule idsort_aln:
    input:
        bam=RUN.output("{sample}/snv-indels/{sample}.snv-indel.bam"),
    output:
        bam=temp(RUN.output("{sample}/snv-indels/{sample}.snv-indel.idsorted.bam")),
    threads: 1
    conda: srcdir("envs/idsort_aln.yml")
    shell:
        "picard SortSam I={input.bam} O={output.bam} SORT_ORDER=queryname"
        " VALIDATION_STRINGENCY=SILENT CREATE_INDEX=false"

rule count_fragments:
    input:
        bam=RUN.output("{sample}/snv-indels/{sample}.snv-indel.idsorted.bam"),
        gtf=RUN.settings["expression_gtf"],
    output:
        count=RUN.output("{sample}/expression/{sample}.fragments_per_gene"),
    threads: 1
    conda: srcdir("envs/count_fragments.yml")
    shell:
        "htseq-count --format bam --order name --stranded no"
        " {input.bam} {input.gtf} > {output.count}"

rule count_raw_bases:
    input:
        bam=RUN.output("{sample}/snv-indels/{sample}.snv-indel.bam"),
        bed=RUN.settings["expression_bed"],
        count_script=RUN.settings["base_count_script"],
    output:
        raw_base_count=RUN.output("{sample}/expression/{sample}.raw_base"),
    threads: 1
    conda: srcdir("envs/count_bases.yml")
    shell:
        "bedtools coverage -split -hist -abam {input.bam} -b {input.bed}"
        " | python {input.count_script} -c 3 > {output.raw_base_count}"

rule count_bases_exon:
    input:
        raw=RUN.output("{sample}/expression/{sample}.raw_base"),
        aggr_script=RUN.settings["aggr_base_count_script"],
    output:
        count=RUN.output("{sample}/expression/{sample}.bases_per_exon"),
    params:
        sample="{sample}"
    threads: 1
    conda: srcdir("envs/count_bases.yml")
    shell:
        "Rscript {input.aggr_script} -I {input.raw} -N {params.sample}"
        " -E {output.count}"

rule count_bases_gene:
    input:
        raw=RUN.output("{sample}/expression/{sample}.raw_base"),
        aggr_script=RUN.settings["aggr_base_count_script"],
    output:
        count=RUN.output("{sample}/expression/{sample}.bases_per_gene"),
    params:
        sample="{sample}"
    threads: 1
    conda: srcdir("envs/count_bases.yml")
    shell:
        "Rscript {input.aggr_script} -I {input.raw} -N {params.sample}"
        " -G {output.count}"

rule calc_exon_ratios:
    input:
        table=RUN.output("{sample}/expression/{sample}.bases_per_exon"),
        calc_script=RUN.settings["calc_ratio_script"],
    output:
        table=RUN.output("{sample}/expression/{sample}.exon_ratios"),
    params:
        exon_ratio_names=" ".join([RUN.settings["relative_gene_name"]] +
                                  RUN.settings.get("exon_names")),
        exon_min_ratio=RUN.settings["exon_min_ratio"],
    threads: 1
    conda: srcdir("envs/calc_ratio.yml")
    shell:
        "cat {input.table}"
        " | python {input.calc_script} -r {params.exon_min_ratio}"
        " - {params.exon_ratio_names}"
        " > {output.table}"
